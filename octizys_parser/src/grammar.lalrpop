use std::str::FromStr;
use octizys_cst::cst::{Between,Token,TrailingList,TokenInfo,CommentKind,LineCommentStart,Comment,ImportItem,Import,OperatorName};
use octizys_common::module_logic_path::ModuleLogicPath;
use octizys_common::identifier::Identifier;
use crate::lexer;

grammar;

// All tokens already have the information of the comments
// right before them and right after them in the same line.
// The different parts of the CST (Concret Syntax Tree)
// may choose to move them a little above to be part of the
// comments of a piece of the CST.
// This will have a global effect in the formatter.

extern {
    type Location = usize;
    type Error = lexer::LexerError;

    enum lexer::Token {
      "," => lexer::Token::Comma(TokenInfo)
      ,":" => lexer::Token::Colon(TokenInfo)
      ,";" => lexer::Token::StatementEnd(TokenInfo)
      ,"." => lexer::Token::Dot(TokenInfo)
      ,"::" => lexer::Token::ModuleSeparator(TokenInfo)
      ,"|" => lexer::Token::CaseSeparator(TokenInfo)
      ,"(" => lexer::Token::LParen(TokenInfo)
      ,")" => lexer::Token::RParen(TokenInfo)
      ,"{" => lexer::Token::LBrace(TokenInfo)
      ,"}" => lexer::Token::RBrace(TokenInfo)
      ,"[" => lexer::Token::LBracket(TokenInfo)
      ,"]" => lexer::Token::RBracket(TokenInfo)
      ,"->" => lexer::Token::RightArrow(TokenInfo)
      ,"<-" => lexer::Token::LeftArrow(TokenInfo)
      ,"->" => lexer::Token::Interrogation(TokenInfo)
      ,"<-" => lexer::Token::Exclamation(TokenInfo)
      ,Import => lexer::Token::Import(TokenInfo)
      ,Export => lexer::Token::Export(TokenInfo)
      ,Data => lexer::Token::Data(TokenInfo)
      ,Newtype => lexer::Token::Newtype(TokenInfo)
      ,Alias => lexer::Token::Alias(TokenInfo)
      ,As => lexer::Token::As(TokenInfo)
      ,Unqualified => lexer::Token::Unqualified(TokenInfo)
      ,Forall => lexer::Token::Forall(TokenInfo)
      ,Type => lexer::Token::Type(TokenInfo)
      ,Bool => lexer::Token::Bool(TokenInfo)
      ,True => lexer::Token::True(TokenInfo)
      ,False => lexer::Token::False(TokenInfo)
      ,Unit => lexer::Token::Unit(TokenInfo)
      ,U8 => lexer::Token::U8(TokenInfo)
      ,U16 => lexer::Token::U16(TokenInfo)
      ,U32 => lexer::Token::U32(TokenInfo)
      ,U64 => lexer::Token::U64(TokenInfo)
      ,I8 => lexer::Token::I8(TokenInfo)
      ,I16 => lexer::Token::I16(TokenInfo)
      ,I32 => lexer::Token::I32(TokenInfo)
      ,I64 => lexer::Token::I64(TokenInfo)
      ,F32 => lexer::Token::F32(TokenInfo)
      ,F64 => lexer::Token::F64(TokenInfo)
      ,StringLiteral => lexer::Token::StringLiteral(TokenInfo,String)
      ,UintLiteral => lexer::Token::UintLiteral(TokenInfo,String)
      ,UFloatLiteral=> lexer::Token::UFloatLiteral(TokenInfo,String)
      ,Identifier=> lexer::Token::Identifier(TokenInfo,String)
      ,OperatorName=> lexer::Token::OperatorName(TokenInfo,String)
      ,ModuleLogicPath=> lexer::Token::ModuleLogicPath(TokenInfo,String)
    }
}

//Macros

separated_list<T,sep>: TrailingList<T> ={
  <t:T> <mut acc: (sep T)*>=> (t,acc,None).into()
  };

terminated_list<T,sep> : TrailingList<T> =
  <t:T> <mut acc: (sep T)*> <s:sep>=> (t,acc,Some(s)).into();

trailing_list<T,sep> : TrailingList<T> = {separated_list<T,sep>,terminated_list<T,sep>}

between<left,T,right> : Between<T> =
  <l:left> <t:T> <r:right>
  => Between{left:l.into(),right:r.into(),value:t};

//Terminal translation

pub string = StringLiteral;

module_path : Token<ModuleLogicPath>  =
  ModuleLogicPath =>? lexer::module_token_to_token(<>);

identifier : Token<Identifier> = Identifier =>? lexer::identifier_token_to_token(<>);
operator_name : Token<OperatorName> = OperatorName =>? lexer::operator_token_to_token(<>);

//We can hack the lexer to do the split of the path from the
//head, but we choose to do this instead.
//We may consider the other approach if we get a conflict in lalrpop.
imported_variable : Token<NamedVariable> =
  module_path => {
  let (maybe_remain,head) = <>.split_head();
  // The regex in the lexer is `(identifier ::)+ identifier`
  let remain = maybe_remain.unwrap();
  NamedVariable::PrefixedVariable{prefix:remain,name:head}
  };

//The comments right before or after the last :: are moved to be before the
// module prefix and we do the same to the before comments on the operator.
// The only part of the operator comments that is preserved is the after
// comment if it exists.
// ```
// {- original comment before -}
// a::b::c -- some comment0
//   -- some comment1
//   :: -- some comment2
// {- some comment3 -}
//      +++  -- some comment4
// ```
// Becomes
// ```
// {- original comment before -}
// -- some comment0
// -- some comment1
// -- some comment2
// {- some comment3 -}
// a::b::c::++ -- some comment4
// ```
// in the CST
// Note that the lexer prevents comments before or after the others ::
imported_operator : Token<NamedVariable> =
  <prefix:module_path> <sep:ModuleSeparator> <operator:operator>
  =>
  {
  //TODO finish this.
  let Token{value:prefix_path, info: TokenInfo{prefix_span,token_info}} = prefix;
  let info = prefix_info.move_after_to_before();
  let CommentsInfo()
  info.extend(sep.info.before);
  info.push(sep.info.after);
  cst::Token{ value:NamedVariable::PrefixedOperator{prefix,operator,separator:sep.info} , info:}
  }

local_variable : Token<NamedVariable> =
  identifier => id



import_item : ImportItem ={
  identifier => ImportItem::Variable(<>),
  operator => ImportItem::Operator(<>),
  <t:Type> <o:operator> => ImportItem::TypeOperator(t.into(),o)
};


//Imports

//TODO: Add constructors


import_list : TrailingList<ImportItem> =
  trailing_list<import_item,","> => <>;
  //sepBy1<import_item,Comma> => some;
  //{
  //import_list Comma import_item => some,
  //import_item => some
  //};

//pub import_declaration : Import =
//  <i:Import> <u:Unqualified?> <p:ModuleLogicPath> between<LParen,<l:import_list>,RParen> <a:(As ModuleLogicPath)?>
//  => some;

import_as : (TokenInfo,Token<ModuleLogicPath>) =
  <a:As> <p:module_path>
  => (a.into(),p);

pub import_declaration : Import =
  <import:Import> <unqualified:Unqualified?> <module_path:module_path>
  <import_list:between<"(",<l:import_list>,")">?>
  <qualified_path:import_as?>
  => Import{
    import:import.into(),
    unqualified:unqualified.map(|x| x.into())
    ,module_path,import_list,qualified_path};

/*
type_basic : Type = {
  U8 => some,
  U16 => some,
  U32 => some,
  U64 => some,
  I8 => some,
  I16 => some,
  I32 => some,
  I64 => some,
  F32 => some,
  F64 => some,
  Bool => some,
};
*/



